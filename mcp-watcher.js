#!/usr/bin/env node

/**
 * MCP File Watcher
 * Monitors file changes and performs automated actions based on MCP configuration
 */

const fs = require('fs');
const path = require('path');
const chokidar = require('chokidar');
const { exec } = require('child_process');

// Configuration
const CONFIG_PATH = path.resolve(__dirname, './mcp.config.js');

// File template cache
const templateCache = new Map();

// Check if configuration exists
if (!fs.existsSync(CONFIG_PATH)) {
  console.error('Error: MCP configuration file not found.');
  process.exit(1);
}

// Load configuration
const config = require(CONFIG_PATH);

// Start file watching
function startWatching() {
  const { watchDirectories, excludePaths, fileTypes } = config.monitoring;
  
  // Create glob pattern for watched paths
  const watchPaths = watchDirectories.map(dir => path.resolve(__dirname, dir));
  
  // Create glob pattern for ignored paths
  const ignoredPaths = excludePaths.map(dir => 
    path.resolve(__dirname, dir)
  );
  
  console.log(`MCP Watcher starting...`);
  console.log(`Watching: ${watchPaths.join(', ')}`);
  console.log(`Ignoring: ${ignoredPaths.join(', ')}`);
  
  // Initialize watcher
  const watcher = chokidar.watch(watchPaths, {
    ignored: ignoredPaths,
    persistent: true,
    ignoreInitial: true
  });
  
  // Set up event handlers
  watcher
    .on('add', path => handleFileCreated(path))
    .on('change', path => handleFileChanged(path))
    .on('unlink', path => handleFileDeleted(path));
    
  console.log('MCP Watcher is now running. Press Ctrl+C to stop.');
}

// Handle file creation
function handleFileCreated(filePath) {
  console.log(`File created: ${filePath}`);
  updateProjectContext();
  maybeCommitChanges([filePath], 'created');
}

// Handle file changes
function handleFileChanged(filePath) {
  console.log(`File changed: ${filePath}`);
  updateProjectContext();
  maybeCommitChanges([filePath], 'updated');
}

// Handle file deletion
function handleFileDeleted(filePath) {
  console.log(`File deleted: ${filePath}`);
  updateProjectContext();
  maybeCommitChanges([filePath], 'deleted');
}

// Create a new file from a template
function createFileFromTemplate(templateName, name) {
  const templates = config.automations.fileTemplates;
  
  if (!templates || !templates[templateName]) {
    console.error(`Template "${templateName}" not found`);
    return false;
  }
  
  const template = templates[templateName];
  const filePath = template.path.replace(/{name}/g, name);
  const content = template.template.replace(/{name}/g, name);
  
  // Create directory if it doesn't exist
  const dirPath = path.dirname(filePath);
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
  }
  
  // Write file
  fs.writeFileSync(filePath, content);
  console.log(`Created file: ${filePath}`);
  
  return filePath;
}

// Update project context
function updateProjectContext() {
  if (!config.contextTracking || !config.contextTracking.enabled) {
    return;
  }
  
  console.log('Updating project context...');
  
  // In a real implementation, you would:
  // 1. Scan the project for dependencies
  // 2. Track component relationships
  // 3. Generate documentation
  
  // Create documentation directory if it doesn't exist
  const docPath = path.dirname(config.contextTracking.documentationPath);
  if (!fs.existsSync(docPath)) {
    fs.mkdirSync(docPath, { recursive: true });
  }
  
  // Update documentation file with timestamp
  const timestamp = new Date().toISOString();
  const docContent = `# Project Context - Updated: ${timestamp}\n\n` +
    `This file is automatically generated by the MCP system.\n\n` +
    `## Project Structure\n\n` +
    `*Generated documentation would go here*\n\n` +
    `## Component Relationships\n\n` +
    `*Component relationship analysis would go here*\n\n`;
  
  fs.writeFileSync(
    config.contextTracking.documentationPath,
    docContent
  );
  
  console.log(`Project context updated: ${config.contextTracking.documentationPath}`);
}

// Maybe commit changes based on configuration
function maybeCommitChanges(filePaths, changeType) {
  const gitConfig = config.automations.git;
  
  if (!gitConfig || !gitConfig.enabled) {
    return;
  }
  
  // Check if any changed files match the paths to auto-commit
  const relevantChanges = filePaths.filter(file => 
    gitConfig.commitOnChanges.some(dir => file.includes(dir))
  );
  
  if (relevantChanges.length === 0) {
    return;
  }
  
  // Format the file list for the commit message
  const fileList = relevantChanges
    .map(file => path.basename(file))
    .join(', ');
  
  // Create commit message
  const message = gitConfig.commitMessage
    .replace('{files}', fileList)
    .replace('{type}', changeType);
  
  // Stage and commit changes
  if (gitConfig.autoStage) {
    console.log(`Auto-staging files: ${fileList}`);
    
    exec('git add ' + relevantChanges.join(' '), (error) => {
      if (error) {
        console.error(`Error staging files: ${error.message}`);
        return;
      }
      
      console.log(`Auto-committing with message: "${message}"`);
      
      exec(`git commit -m "${message}"`, (error) => {
        if (error) {
          console.error(`Error committing: ${error.message}`);
          return;
        }
        
        console.log('Changes committed successfully.');
      });
    });
  }
}

// Start watching files
startWatching(); 